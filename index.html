<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PixelPaint — Пиксельная раскраска</title>
<style>
  :root{
    --bg:#0f1020; --panel:#16172a; --panel-2:#1d1f36; --text:#e8eaf6; --muted:#aeb4d4; --accent:#6c7cff; --accent-2:#64e0a6; --danger:#ff6b6b;
    --shadow:0 10px 30px rgba(0,0,0,.35);
    --radius:18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background: radial-gradient(1200px 600px at 80% -10%, #1b1e3e33, transparent), var(--bg);
    color:var(--text); font: 16px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display:flex; flex-direction:column;
  }
  header{
    display:flex; align-items:center; gap:.8rem; padding:12px 16px; background:linear-gradient(180deg, #1a1b32, #13142a);
    border-bottom:1px solid #2a2d53; position:sticky; top:0; z-index:5;
  }
  header .logo{
    width:40px; height:40px; display:grid; place-items:center; background:linear-gradient(135deg, var(--accent), #9aa4ff);
    color:#fff; border-radius:12px; box-shadow:var(--shadow); font-weight:800;
  }
  header h1{font-size:1.1rem; margin:0; letter-spacing:.3px}
  header .spacer{flex:1}
  header .btn{margin-left:.4rem}

  .app{
    display:grid; grid-template-columns: 280px 1fr; gap:14px; padding:14px; height:calc(100% - 64px);
  }
  @media (max-width: 900px){ .app{ grid-template-columns: 1fr; height:auto } }

  .panel{
    background:linear-gradient(180deg, var(--panel), var(--panel-2)); border:1px solid #252854; border-radius:var(--radius);
    box-shadow: var(--shadow);
  }
  .sidebar{ padding:14px; display:flex; flex-direction:column; gap:12px; }
  .section{ padding:12px; background:#171836; border:1px solid #232558; border-radius:14px; }
  .section h3{ margin:0 0 8px; font-size:.95rem; color:#cfd5ff }

  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .col{ display:flex; flex-direction:column; gap:8px }

  .btn{ appearance:none; border:1px solid #2a2e63; background:linear-gradient(180deg,#252a64,#1b1f4a);
    color:#eaf; padding:10px 12px; border-radius:12px; cursor:pointer; transition:.15s transform, .2s box-shadow, .2s background; font-weight:600;
  }
  .btn:hover{ transform: translateY(-1px); box-shadow:0 8px 18px rgba(0,0,0,.35) }
  .btn:active{ transform: translateY(0) scale(.98) }
  .btn.secondary{ background:linear-gradient(180deg,#1a1d3c,#121432); color:#c9cdf8 }
  .btn.ghost{ background:transparent; border-color:#384188; color:#c9cdf8 }
  .btn.warn{ background:linear-gradient(180deg,#5b1f1f,#3b1414); color:#ffd2d2; border-color:#7a2b2b }
  .btn.ok{ background:linear-gradient(180deg,#1e4e3a,#153629); color:#d2ffe9; border-color:#28684e }
  .btn.active{ outline:2px solid var(--accent-2); box-shadow:0 0 0 4px #64e0a644 }

  .grid{
    display:grid; grid-template-columns:1fr 1fr; gap:12px
  }
  .tool-grid{ display:grid; grid-template-columns:repeat(4,1fr); gap:10px }
  .tool{ display:grid; place-items:center; padding:10px; border:1px solid #2b2f60; border-radius:12px; cursor:pointer; background:#14163a; font-size:13px }
  .tool.active{ outline:2px solid var(--accent); box-shadow:0 0 0 4px #6c7cff44 }

  .palette{ display:grid; grid-template-columns:repeat(8, 1fr); gap:8px }
  .sw{ width:28px; height:28px; border-radius:8px; border:1px solid #0008; cursor:pointer }

  .main{ position:relative; overflow:hidden }
  .stage-wrap{ position:relative; width:100%; height:100%; display:grid; place-items:center; padding:8px }
  .stage{
    position:relative; background:#0a0b15; border:1px solid #252854; border-radius:16px; padding:12px; box-shadow: var(--shadow);
  }
  canvas{ display:block; background:#0d0f23; border-radius:10px; image-rendering: pixelated; }
  .status{ position:absolute; bottom:12px; left:12px; font-size:12px; color:var(--muted); background:#0a0c20a6; padding:6px 10px; border-radius:10px; border:1px solid #232558 }

  label{ font-size:.85rem; color:#cbd1ff }
  input[type="range"]{ width:100% }
  input[type="color"]{ width:100%; height:40px; background:#11143a; border:1px solid #2b2f60; border-radius:10px }
  input[type="number"], select, .text{
    width:100%; padding:10px; background:#12143a; color:#e9ecff; border:1px solid #2b2f60; border-radius:10px;
  }
  .kbd{ background:#10122c; border:1px solid #2a2e63; padding:2px 6px; border-radius:6px; font-size:.8em; color:#cdd2ff }
</style>
</head>
<body>
  <header>
    <div class="logo">PX</div>
    <h1>PixelPaint — пиксельная раскраска</h1>
    <div class="spacer"></div>
    <button class="btn ghost" id="btnHelp">Справка</button>
    <button class="btn ok" id="btnExport">Экспорт PNG</button>
  </header>

  <div class="app">
    <aside class="panel sidebar">
      <div class="section">
        <h3>Полотно</h3>
        <div class="grid">
          <div class="col">
            <label>Ширина (клеток)</label>
            <input id="wInput" type="number" min="4" max="256" step="1" value="32" />
          </div>
          <div class="col">
            <label>Высота (клеток)</label>
            <input id="hInput" type="number" min="4" max="256" step="1" value="32" />
          </div>
        </div>
        <div class="row" style="margin-top:10px">
          <button class="btn" id="btnResize">Создать / Изменить</button>
          <button class="btn secondary" id="btnClear">Очистить</button>
        </div>
        <div class="row" style="margin-top:10px">
          <label><input type="checkbox" id="chkGrid" checked> Показать сетку</label>
        </div>
      </div>

      <div class="section">
        <h3>Инструменты</h3>
        <div class="tool-grid" id="tools">
          <div class="tool active" data-tool="pen" title="Кисть (B)">Кисть</div>
          <div class="tool" data-tool="eraser" title="Ластик (E)">Ластик</div>
          <div class="tool" data-tool="fill" title="Заливка (G)">Заливка</div>
          <div class="tool" data-tool="picker" title="Пипетка (I)">Пипетка</div>
        </div>
        <div class="row" style="margin-top:10px">
          <label style="flex:1">Размер кисти: <span id="brushSizeLabel">1</span></label>
        </div>
        <input id="brushSize" type="range" min="1" max="8" step="1" value="1" />
        <div class="row" style="margin-top:10px; align-items:flex-end">
          <div class="col" style="flex:1">
            <label>Цвет</label>
            <input id="color" type="color" value="#6c7cff" />
          </div>
          <div class="col">
            <label>&nbsp;</label>
            <button class="btn secondary" id="btnAddColor">В палитру</button>
          </div>
        </div>
        <div class="palette" id="palette" style="margin-top:10px"></div>
        <div class="row" style="margin-top:10px">
          <label><input type="checkbox" id="chkMirrorX"> Зеркало по X</label>
          <label><input type="checkbox" id="chkMirrorY"> Зеркало по Y</label>
        </div>
      </div>

      <div class="section">
        <h3>История</h3>
        <div class="row">
          <button class="btn" id="btnUndo" title="Ctrl+Z">Отмена</button>
          <button class="btn" id="btnRedo" title="Ctrl+Y">Повтор</button>
          <button class="btn ghost" id="btnSaveLocal" title="Сохранить в браузере">Сохранить</button>
          <button class="btn ghost" id="btnLoadLocal" title="Загрузить из браузера">Загрузить</button>
        </div>
      </div>

      <div class="section">
        <h3>Навигация</h3>
        <div class="row">
          <label>Масштаб: <span id="zoomLabel">100%</span></label>
        </div>
        <input id="zoom" type="range" min="10" max="400" value="100" />
        <div class="row" style="margin-top:6px">
          <span class="kbd">Space</span> — перетаскивание • <span class="kbd">Ctrl</span> + колесо — зум
        </div>
      </div>

    </aside>

    <main class="panel main">
      <div class="stage-wrap">
        <div class="stage">
          <canvas id="canvas" width="512" height="512"></canvas>
          <div class="status" id="status">Готово</div>
        </div>
      </div>
    </main>
  </div>

<script>
(function(){
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  const wInput = document.getElementById('wInput');
  const hInput = document.getElementById('hInput');
  const btnResize = document.getElementById('btnResize');
  const btnClear = document.getElementById('btnClear');
  const chkGrid = document.getElementById('chkGrid');
  const toolsEl = document.getElementById('tools');
  const brushSize = document.getElementById('brushSize');
  const brushSizeLabel = document.getElementById('brushSizeLabel');
  const color = document.getElementById('color');
  const palette = document.getElementById('palette');
  const btnAddColor = document.getElementById('btnAddColor');
  const chkMirrorX = document.getElementById('chkMirrorX');
  const chkMirrorY = document.getElementById('chkMirrorY');
  const btnUndo = document.getElementById('btnUndo');
  const btnRedo = document.getElementById('btnRedo');
  const btnSaveLocal = document.getElementById('btnSaveLocal');
  const btnLoadLocal = document.getElementById('btnLoadLocal');
  const zoom = document.getElementById('zoom');
  const zoomLabel = document.getElementById('zoomLabel');
  const status = document.getElementById('status');
  const btnExport = document.getElementById('btnExport');
  const btnHelp = document.getElementById('btnHelp');

  let cols = 32, rows = 32;
  let grid = new Uint32Array(cols*rows); // ARGB packed
  let history = []; let redoStack = [];
  let tool = 'pen';
  let px = 0, py = 0; // pan
  let scale = 1;
  let isPanning = false; let isDrawing = false;

  const defaultPalette = ['#000000','#ffffff','#ff6b6b','#ffd166','#64e0a6','#6c7cff','#8b5cf6','#22d3ee','#f97316','#9ca3af','#16a34a','#ef4444','#eab308','#d946ef'];

  function pushHistory(){ history.push(grid.slice()); if(history.length>50) history.shift(); redoStack.length=0; }
  function undo(){ if(history.length){ redoStack.push(grid.slice()); grid = history.pop(); render(); setStatus('Отмена'); } }
  function redo(){ if(redoStack.length){ history.push(grid.slice()); grid = redoStack.pop(); render(); setStatus('Повтор'); } }

  function setStatus(t){ status.textContent=t; clearTimeout(setStatus.t); setStatus.t=setTimeout(()=>status.textContent='Готово',1200); }

  function hexToARGB(hex){
    if(hex.length===4){ const r=parseInt(hex[1]+hex[1],16), g=parseInt(hex[2]+hex[2],16), b=parseInt(hex[3]+hex[3],16); return (0xff<<24)|(r<<16)|(g<<8)|b; }
    const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
    return (0xff<<24)|(r<<16)|(g<<8)|b;
  }
  function argbToHex(v){ const r=(v>>16)&255,g=(v>>8)&255,b=v&255; return '#'+[r,g,b].map(x=>x.toString(16).padStart(2,'0')).join(''); }

  function idx(x,y){ return y*cols+x; }

  function resizeGrid(w,h){
    cols=w; rows=h; const ng=new Uint32Array(cols*rows);
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){
      if(x<w && y<h){} // just new empty
    }
    grid = ng; history=[]; redoStack=[]; pushHistory(); render();
  }

  function clearGrid(){ pushHistory(); grid.fill(0); render(); }

  function paintAt(x,y,brush, colorARGB){
    pushHistory();
    const half = Math.floor(brush/2);
    for(let oy=-half; oy<=half; oy++){
      for(let ox=-half; ox<=half; ox++){
        const tx = x+ox, ty = y+oy;
        if(tx>=0 && ty>=0 && tx<cols && ty<rows){ grid[idx(tx,ty)] = colorARGB; }
        if(chkMirrorX.checked){ const mx = cols-1-tx; if(mx>=0 && mx<cols) grid[idx(mx,ty)] = colorARGB; }
        if(chkMirrorY.checked){ const my = rows-1-ty; if(my>=0 && my<rows) grid[idx(tx,my)] = colorARGB; }
        if(chkMirrorX.checked && chkMirrorY.checked){ const mx = cols-1-tx, my = rows-1-ty; if(mx>=0&&my>=0&&mx<cols&&my<rows) grid[idx(mx,my)] = colorARGB; }
      }
    }
    render();
  }

  function eraseAt(x,y,brush){ paintAt(x,y,brush,0); }

  function fillAt(x,y,newColor){
    const target = grid[idx(x,y)]; if(target===newColor) return;
    pushHistory();
    const q=[[x,y]]; const seen=new Set([idx(x,y)]);
    while(q.length){
      const [cx,cy]=q.pop(); const i=idx(cx,cy);
      if(grid[i]!==target) continue; grid[i]=newColor;
      const neigh=[[cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]];
      for(const [nx,ny] of neigh){ if(nx>=0&&ny>=0&&nx<cols&&ny<rows){ const id=idx(nx,ny); if(!seen.has(id)){ seen.add(id); q.push([nx,ny]); } } }
    }
    render();
  }

  function getCellFromClient(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left - 12 - px) / (cellSize()*scale);
    const y = (clientY - rect.top - 12 - py) / (cellSize()*scale);
    return {x:Math.floor(x), y:Math.floor(y)};
  }

  function cellSize(){ // base pixel size in canvas pixels
    // Fit grid into canvas area keeping square cells
    const size = Math.floor(Math.min((canvas.width-2)/cols, (canvas.height-2)/rows));
    return Math.max(1,size);
  }

  function render(){
    const cs = cellSize();
    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.translate(12+px,12+py);
    ctx.scale(scale, scale);
    // draw pixels
    for(let y=0;y<rows;y++){
      for(let x=0;x<cols;x++){
        const v = grid[idx(x,y)];
        if(v>>>24){
          ctx.fillStyle = argbToHex(v);
          ctx.fillRect(x*cs, y*cs, cs, cs);
        }
      }
    }
    // grid
    if(chkGrid.checked){
      ctx.strokeStyle = '#2b2f60'; ctx.lineWidth = 1/DPR;
      ctx.beginPath();
      for(let x=0;x<=cols;x++){ ctx.moveTo(x*cs+0.5, 0); ctx.lineTo(x*cs+0.5, rows*cs); }
      for(let y=0;y<=rows;y++){ ctx.moveTo(0, y*cs+0.5); ctx.lineTo(cols*cs, y*cs+0.5); }
      ctx.stroke();
    }
    // outline
    ctx.strokeStyle = '#3a3f78'; ctx.lineWidth=2/DPR; ctx.strokeRect(0,0,cols*cs, rows*cs);
    ctx.restore();
  }

  function resizeCanvas(){
    const stage = document.querySelector('.stage');
    const padding = 24; // internal padding in stage
    const ww = stage.clientWidth - padding;
    const hh = Math.min(window.innerHeight - 200, 900);
    canvas.width = Math.floor(ww * DPR);
    canvas.height = Math.floor(hh * DPR);
    canvas.style.width = ww + 'px';
    canvas.style.height = hh + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    render();
  }

  // Interaction
  let lastPos=null; let spaceDown=false; let ctrlDown=false;
  function onPointerDown(e){
    const isTouch = e.pointerType==='touch' || e.type==='touchstart';
    canvas.setPointerCapture(e.pointerId||1);
    const pos=getCellFromClient(e.clientX, e.clientY);
    if(spaceDown){ isPanning=true; lastPos={x:e.clientX,y:e.clientY}; return; }
    isDrawing=true; actAtPos(pos);
  }
  function actAtPos(pos){
    if(pos.x<0||pos.y<0||pos.x>=cols||pos.y>=rows) return;
    const b = parseInt(brushSize.value,10);
    const c = hexToARGB(color.value);
    if(tool==='pen') paintAt(pos.x,pos.y,b,c);
    else if(tool==='eraser') eraseAt(pos.x,pos.y,b);
    else if(tool==='fill') fillAt(pos.x,pos.y,c);
    else if(tool==='picker'){ color.value = argbToHex(grid[idx(pos.x,pos.y)] || 0); setStatus('Выбран цвет'); }
  }
  function onPointerMove(e){
    const pos=getCellFromClient(e.clientX, e.clientY);
    if(isPanning && lastPos){ px += (e.clientX-lastPos.x); py += (e.clientY-lastPos.y); lastPos={x:e.clientX,y:e.clientY}; render(); return; }
    if(isDrawing && (tool==='pen'||tool==='eraser')) actAtPos(pos);
  }
  function onPointerUp(){ isPanning=false; isDrawing=false; lastPos=null; }

  canvas.addEventListener('pointerdown', onPointerDown);
  canvas.addEventListener('pointermove', onPointerMove);
  window.addEventListener('pointerup', onPointerUp);

  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){ spaceDown=true; }
    if(e.ctrlKey && (e.key==='z'||e.key==='я')){ e.preventDefault(); undo(); }
    if(e.ctrlKey && (e.key==='y')){ e.preventDefault(); redo(); }
    if(e.key==='b' || e.key==='и') setTool('pen');
    if(e.key==='e' || e.key==='у') setTool('eraser');
    if(e.key==='g' || e.key==='п') setTool('fill');
    if(e.key==='i' || e.key==='ш') setTool('picker');
  });
  window.addEventListener('keyup', (e)=>{ if(e.code==='Space') spaceDown=false; });

  canvas.addEventListener('wheel', (e)=>{
    if(e.ctrlKey){ e.preventDefault(); const delta = Math.sign(e.deltaY); const z = parseInt(zoom.value,10); const nz=Math.min(400,Math.max(10,z - delta*10)); zoom.value=nz; onZoomInput(); }
  }, { passive:false });

  function onZoomInput(){ const z = parseInt(zoom.value,10); zoomLabel.textContent=z+'%'; scale=z/100; render(); }

  function setTool(id){ tool=id; [...toolsEl.children].forEach(t=>t.classList.toggle('active', t.dataset.tool===id)); setStatus('Инструмент: '+id); }
  toolsEl.addEventListener('click', (e)=>{ const t=e.target.closest('.tool'); if(t) setTool(t.dataset.tool); });

  brushSize.addEventListener('input', ()=>{ brushSizeLabel.textContent=brushSize.value; });

  btnResize.addEventListener('click', ()=>{
    const w=Math.max(4, Math.min(256, parseInt(wInput.value,10)||32));
    const h=Math.max(4, Math.min(256, parseInt(hInput.value,10)||32));
    resizeGrid(w,h); setStatus(`Полотно ${w}×${h}`);
  });
  btnClear.addEventListener('click', ()=>{ if(confirm('Очистить полотно?')){ clearGrid(); } });

  chkGrid.addEventListener('change', render);
  zoom.addEventListener('input', onZoomInput);

  btnAddColor.addEventListener('click', ()=>{ addToPalette(color.value); savePalette(); });

  function addToPalette(hex){ const sw=document.createElement('button'); sw.className='sw'; sw.style.background=hex; sw.title=hex; sw.addEventListener('click',()=>{ color.value=hex; }); palette.appendChild(sw); }
  function loadPalette(){ const saved = JSON.parse(localStorage.getItem('px_palette')||'null'); const list = saved && Array.isArray(saved)? saved : defaultPalette; palette.innerHTML=''; list.forEach(addToPalette); }
  function savePalette(){ const list=[...palette.querySelectorAll('.sw')].map(sw=>rgbToHex(getComputedStyle(sw).backgroundColor)); localStorage.setItem('px_palette', JSON.stringify(list)); }

  function rgbToHex(rgb){ const m=rgb.match(/\d+/g).map(Number); return '#'+m.slice(0,3).map(x=>x.toString(16).padStart(2,'0')).join(''); }

  btnUndo.addEventListener('click', undo);
  btnRedo.addEventListener('click', redo);

  btnSaveLocal.addEventListener('click', ()=>{
    const data = { cols, rows, grid: Array.from(grid) };
    localStorage.setItem('px_project', JSON.stringify(data));
    setStatus('Сохранено в браузер');
  });
  btnLoadLocal.addEventListener('click', ()=>{
    const data = JSON.parse(localStorage.getItem('px_project')||'null');
    if(!data) return alert('Нет сохранённого проекта');
    cols=data.cols; rows=data.rows; grid = Uint32Array.from(data.grid);
    wInput.value=cols; hInput.value=rows; history=[]; redoStack=[]; pushHistory(); render(); setStatus('Загружено');
  });

  btnExport.addEventListener('click', ()=>{
    // экспорт в PNG без сетки, с точным размером клеток = 1px масштабирования
    const cs=1; const out=document.createElement('canvas'); out.width=cols; out.height=rows; const octx=out.getContext('2d');
    const img=octx.createImageData(cols,rows); const d=img.data;
    for(let i=0;i<grid.length;i++){
      const v=grid[i]; const a=(v>>>24)&255; const r=(v>>>16)&255; const g=(v>>>8)&255; const b=v&255; const k=i*4;
      d[k]=r; d[k+1]=g; d[k+2]=b; d[k+3]=a;
    }
    octx.putImageData(img,0,0);
    const url = out.toDataURL('image/png');
    const a=document.createElement('a'); a.href=url; a.download=`pixelpaint_${cols}x${rows}.png`; a.click();
  });

  btnHelp.addEventListener('click', ()=>{
    alert(`Управление:\n\n— Инструменты: B — кисть, E — ластик, G — заливка, I — пипетка\n— Ctrl+Z / Ctrl+Y — отмена/повтор\n— Колесо с Ctrl — масштаб, Space + перетаскивание — панорама\n— Зеркало X/Y — симметричное рисование\n— Сохранение — в браузер, Экспорт — PNG файл`);
  });

  function init(){
    loadPalette();
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    resizeGrid(cols, rows);
    onZoomInput();
  }
  init();
})();
</script>
</body>
</html>
